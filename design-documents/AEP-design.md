Of course. As a senior technical architect and prompt engineering expert, I will craft a comprehensive, optimized prompt designed to generate a detailed and actionable design document from a given task description.

Here is the optimized prompt:

---

**Role:** You are a Senior Technical Architect with 15+ years of experience designing scalable, secure, and maintainable software systems. You are methodical, detail-oriented, and excel at creating clear, comprehensive documentation that serves as a single source of truth for engineering teams, product managers, and stakeholders.

**Task:** Based on the following **Task Description**, generate a complete and professional **System Design Document** in Markdown format.

**Task Description:**
{description}

**Instructions for Generating the Design Document:**

1.  **Project Overview & Goals:**
    *   Begin with a high-level executive summary of the system to be built.
    *   Clearly define the primary **Goals** (what the system *will* achieve). Present these as a bulleted list.
    *   Explicitly state the **Non-Goals** (what is out of scope for this specific project phase). This is critical for managing scope creep. Present these as a separate bulleted list.
    *   **Rationale:** This section sets the context and aligns all readers on the project's purpose and boundaries.

2.  **System Architecture:**
    *   Describe the high-level architectural pattern (e.g., Microservices, Monolith, Serverless, Event-Driven).
    *   Include a **Mermaid.js code block** generating a clear system architecture diagram illustrating all major components, data flows, and external integrations.
    *   Justify the chosen architecture, explaining how it supports the project's goals, scalability needs, and team structure.
    *   **Rationale:** A visual and descriptive architecture provides a mental model for the entire team and is essential for understanding how components interact.

3.  **Component Descriptions:**
    *   Break down the architecture into its constituent components (e.g., `AuthService`, `UserProfileAPI`, `DataIngestionWorker`, `Frontend App`).
    *   For each major component, provide:
        *   **Purpose:** A single sentence on its responsibility.
        *   **Technology Stack:** Proposed languages, frameworks, and databases (e.g., "Node.js, Express, PostgreSQL").
        *   **Key Functions:** A bulleted list of its primary operations.
    *   **Rationale:** This decomposes the system into manageable, assignable units of work for the development team.

4.  **Data Models:**
    *   Define the core entities and their relationships (e.g., `User`, `Order`, `Product`).
    *   Provide detailed schemas for at least two critical entities using a Markdown table format, showing field names, types, constraints, and descriptions.
    *   Discuss the choice of data storage (SQL vs. NoSQL) and justify it based on the data structure and access patterns.
    *   **Example:**
        | Field | Type | Required | Description |
        | :--- | :--- | :--- | :--- |
        | `id` | UUID | Yes | Primary key, generated by the database. |
        | `email` | string | Yes | Unique user identifier. |
        | `password_hash` | string | Yes | Hashed and salted password. |

5.  **API Interfaces:**
    *   Specify the API design style (RESTful, GraphQL, gRPC) and justify the choice.
    *   Detail the endpoints for at least two key components. For each endpoint, include:
        *   **HTTP Method & Path** (e.g., `POST /api/v1/users`)
        *   **Request Body Schema** (JSON example)
        *   **Response Body Schema** (JSON example for success and error)
        *   **Authentication Required?** (Yes/No)
    *   **Rationale:** Well-defined APIs are contracts between frontend and backend teams, enabling parallel development.

6.  **User Interface Design:**
    *   Describe the UI framework(s) to be used (e.g., React, Angular, Thymeleaf).
    *   Outline the key user screens/flows (e.g., "User Registration Flow," "Dashboard View").
    *   **Include a link to a placeholder for the UI wireframes/mockups** (e.g., `[Link to Figma Board]`). *Note: You cannot generate images, but you must instruct the team to create and link them here.*
    *   **Rationale:** This connects the technical system to the user experience and guides frontend development.

7.  **Security Measures:**
    *   Detail authentication and authorization strategies (e.g., JWT, OAuth 2.0, Role-Based Access Control).
    *   List specific security considerations: Data encryption (at rest and in transit), input validation, handling of sensitive data (PII), and mitigation of common vulnerabilities (OWASP Top 10).
    *   **Rationale:** Proactively addressing security is non-negotiable and must be baked into the design, not bolted on later.

8.  **Performance & Scaling:**
    *   Define performance targets (e.g., p95 latency < 200ms, system availability 99.9%).
    *   Describe scaling strategies for both the application and database (e.g., horizontal scaling via Kubernetes, read replicas, caching with Redis).
    *   Identify potential performance bottlenecks and how the architecture addresses them.
    *   **Rationale:** This ensures the system will remain responsive and reliable as user load grows.

9.  **Implementation Strategy:**
    *   Propose a phased rollout plan (e.g., MVP Phase 1, Phase 2, etc.).
    *   Suggest a development workflow (e.g., GitFlow, trunk-based development).
    *   Recommend a CI/CD pipeline setup (e.g., using GitHub Actions/GitLab CI).
    *   **Rationale:** A clear plan helps with project management and ensures a smooth path to production.

10. **Risks & Mitigations:**
    *   Identify technical and project risks (e.g., "Third-party API rate limiting," "Database schema migration complexities," "Scope creep").
    *   For each risk, propose a concrete mitigation or contingency plan.
    *   **Rationale:** Demonstrates foresight and prepares the team to handle challenges effectively.

11. **Testing Strategy:**
    *   Outline a multi-layered testing approach: Unit tests, Integration tests, End-to-End (E2E) tests, and Load tests.
    *   Specify the desired test coverage target for critical paths (e.g., "80% unit test coverage for core services").
    *   Mention any testing frameworks or tools to be used (e.g., Jest, Cypress, JMeter).
    *   **Rationale:** A robust testing strategy is crucial for maintaining quality and enabling rapid iteration.

12. **Dependencies:**
    *   List all critical external dependencies (e.g., "AWS S3 for file storage," "SendGrid for email," "Stripe API for payments").
    *   List internal dependencies on other teams or systems.
    *   **Rationale:** Makes the team aware of external factors that could impact development or cause outages.

13. **Success Metrics:**
    *   Define quantitative metrics to measure the system's success post-launch. These should be tied to the project goals.
    *   Examples: User sign-up rate, API error rate (< 0.1%), average response time, business transaction volume.
    *   **Rationale:** Provides a data-driven way to evaluate the project's impact and identify areas for improvement.

14. **Conclusion & Next Steps:**
    *   Summarize the key design decisions and their justifications.
    *   Provide a clear, actionable list of immediate next steps for the engineering team (e.g., "1. Set up project repositories. 2. Finalize API contracts. 3. Create initial infrastructure as code (IaC) templates.").

**Output Format:** Generate the entire response as a well-structured Markdown document. Use appropriate headings (`## H2`, `### H3`), bullet points, tables, and code blocks to ensure clarity and readability. The document should be self-contained and ready to be used by a development team to begin implementation.

---